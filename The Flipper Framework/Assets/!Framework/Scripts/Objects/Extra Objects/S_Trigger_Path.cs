using System;
using UnityEngine;
using SplineMesh;
using System.Collections.Generic;
using System.Linq;

[ExecuteInEditMode]
[SelectionBase]
[DisallowMultipleComponent]
public class S_Trigger_Path : MonoBehaviour
{

	[Header("Path Data")]
	public Spline spline;
	public Vector2 _speedLimits = new Vector2(30, 200);
	public bool         _canPlayerReverse = false;
	public bool         _canPlayerSlow = false;
	public int          _lockPlayerFor = 40;

	[Header("Immediate")]
	public bool         _removeVerticalVelocityOnStart = true;

	[Header("Triggers")]
	public bool _willUpdateInRealTime = true;

	[SerializeField] bool _hasEnterTrigger = true;
	[SerializeField] bool _hasExitTrigger = true;

	[Header("Size")]
	[SerializeField] Vector3 _enterSize;
	[SerializeField] Vector3 _exitSize;
	[Header("Offset")]
	[SerializeField] Vector3 _enterOffset;
	[SerializeField] Vector3 _exitOffset;

	private GameObject		_generated;
	private S_DeactivateOnStart	_DeactivateOnStart;


	// Update is called once per frame
	private void Update () {
		// we can prevent the generated content to be updated during playmode to preserve baked data saved in the scene
		if (!_willUpdateInRealTime || Application.isPlaying) return;
	
		CreateOrSetTriggers();	
	}

	private void OnEnable () {
		// tip : if you name all generated content in the same way, you can easily find all of it
		// at once in the scene view, with a single search.
		string generatedName = "generated by " + GetType().Name;
		var generatedTranform = transform.Find(generatedName);
		_generated = generatedTranform != null ? generatedTranform.gameObject : UOUtility.Create(generatedName, gameObject);

	}

	//Goes through each desired trigger, and creates or sets it to the desired values.
	public void CreateOrSetTriggers () {
		var used = new List<GameObject>();

		if (_hasEnterTrigger)
		{
			var go = FindOrCreate("Enter");
			used.Add(go);
		}

		if (_hasExitTrigger)
		{
			var go = FindOrCreate("Exit");
			used.Add(go);
		}



		//Destroy the child objects not in Used. This is classic pooling to recycle game objects.
		foreach (var eg in _generated.transform
		    .Cast<Transform>()
		    .Select(child => child.gameObject).Except(used))
		{
			UOUtility.Destroy(eg);
		}
	}

	private GameObject FindOrCreate ( string name ) {
		var childTransform = _generated.transform.Find(name);
		GameObject res;
		if (childTransform == null)
		{
			res = UOUtility.Create(name,
			    _generated,
			    typeof(S_DeactivateOnStart),
			    typeof(BoxCollider));
			res.isStatic = true;
		}
		else
		{
			res = childTransform.gameObject;
		}
		res.GetComponent<S_DeactivateOnStart>().enabled = _DeactivateOnStart;
		res.tag = "PathTrigger";
		res.layer = 0;

		BoxCollider boxCol = res.GetComponent<BoxCollider>();

		if (name == "Enter")
		{
			CurveSample Sample = spline.GetSampleAtDistance(0);

			res.transform.rotation = Quaternion.LookRotation(transform.rotation * Sample.tangent, transform.rotation * Sample.up);
			res.transform.position = transform.position + (transform.rotation * Sample.location) + res.transform.rotation * _enterOffset;
			boxCol.size = _enterSize;

		}

		else if (name == "Exit" )
		{
			CurveSample Sample = spline.GetSampleAtDistance(spline.Length - 1);

			res.transform.rotation = Quaternion.LookRotation(transform.rotation * Sample.tangent, transform.rotation * Sample.up) ;
			res.transform.position = transform.position + (transform.rotation * Sample.location) + res.transform.rotation * _exitOffset;
			boxCol.size = _exitSize;
		}

		boxCol.isTrigger = true;

		return res;
	}

}
