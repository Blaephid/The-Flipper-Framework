using System;
using UnityEngine;
using SplineMesh;
using System.Collections.Generic;
using System.Linq;

[ExecuteInEditMode]
[SelectionBase]
[DisallowMultipleComponent]
public class S_Trigger_Path : MonoBehaviour
{
    public Spline spline;

    public bool updateInPlayMode = true;
    private bool toUpdate = false;

    [SerializeField] bool Enter = true;
    [SerializeField] bool Exit = true;
    [SerializeField] bool End = true;

    [SerializeField] Vector3 EnterSize;
    [SerializeField] Vector3 ExitSize;
    [SerializeField] Vector3 EnterOffset;
    [SerializeField] Vector3 ExitOffset;
    [SerializeField] Quaternion EnterRotation;
    [SerializeField] Quaternion ExitRotation;

    private GameObject generated;
    private S_DeactivateOnStart DeactivateOnStart;


    // Update is called once per frame
    private void Update()
    {
        // we can prevent the generated content to be updated during playmode to preserve baked data saved in the scene
        if (!updateInPlayMode && Application.isPlaying) return;

        if (toUpdate)
        {
            //toUpdate = false;
            CreateMeshes();
        }
    }

    private void OnEnable()
    {
        // tip : if you name all generated content in the same way, you can easily find all of it
        // at once in the scene view, with a single search.
        string generatedName = "generated by " + GetType().Name;
        var generatedTranform = transform.Find(generatedName);
        generated = generatedTranform != null ? generatedTranform.gameObject : UOUtility.Create(generatedName, gameObject);

        toUpdate = true;
    }

    private void OnValidate()
    {
        toUpdate = true;
    }

    public void CreateMeshes()
    {
        var used = new List<GameObject>();


        

        if (Enter)
        {
            var go = FindOrCreate("Enter");
            used.Add(go);
        }
        
        if (Exit)
        {
            var go = FindOrCreate("Exit");
            used.Add(go);
        }

        if (End)
        {
            var go = FindOrCreate("End");
            used.Add(go);
        }


        // we destroy the unused objects. This is classic pooling to recycle game objects.
        foreach (var eg in generated.transform
            .Cast<Transform>()
            .Select(child => child.gameObject).Except(used))
        {
            UOUtility.Destroy(eg);
        }
    }

    private GameObject FindOrCreate(string name)
    {
        var childTransform = generated.transform.Find(name);
        GameObject res;
        if (childTransform == null)
        {
            res = UOUtility.Create(name,
                generated,
                typeof(S_DeactivateOnStart),
                typeof(BoxCollider));
            res.isStatic = true;
        }
        else
        {
            res = childTransform.gameObject;
        }
        res.GetComponent<S_DeactivateOnStart>().enabled = DeactivateOnStart;
        res.tag = "PathTrigger";
        res.layer = 0;

        BoxCollider boxCol = res.GetComponent<BoxCollider>();

        if (name == "Enter")
        {
            res.transform.localPosition = spline.nodes[0].Position + EnterOffset;
            boxCol.size = EnterSize;
            res.transform.rotation = EnterRotation;
        }

        else if (name == "Exit" || name == "End")
        {
            int lastPos = spline.nodes.Count - 1;
            res.transform.localPosition = spline.nodes[lastPos].Position + ExitOffset;
            boxCol.size = ExitSize;
            res.transform.rotation = ExitRotation;
        }

        boxCol.isTrigger = true;


        return res;
    }

}
