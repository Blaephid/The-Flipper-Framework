using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using System.ComponentModel;

#if UNITY_EDITOR
using UnityEditor;
#endif
namespace SplineMesh
{
	/// <summary>
	/// Example of component to places assets along a spline. This component can be used as-is but will most likely be a base for your own component.
	/// 
	/// In this example, the user gives the prefab to place, a spacing value between two placements, the prefab scale and an horizontal offset to the spline.
	/// These three last values have an additional range, allowing to add some randomness. for each placement, the computed value will be between value and value+range.
	/// 
	/// Prefabs are placed from the start of the spline at computed spacing, unitl there is no lentgh remaining. Prefabs are stored, destroyed
	/// and built again each time the spline or one of its curves change.
	/// 
	/// A random seed is used to obtain the same random numbers at each update. The user can specify the seed to test some other random number set.
	/// 
	/// Place prefab along a spline and deform it easily have a lot of usages if you have some imagination : 
	///  - place trees along a road
	///  - create a rocky bridge
	///  - create a footstep track with decals
	///  - create a path of firefly in the dark
	///  - create a natural wall with overlapping rocks
	///  - etc.
	/// </summary>
	[ExecuteInEditMode]
	[SelectionBase]
	[DisallowMultipleComponent]
	public class S_PlaceOnSpline : MonoBehaviour
	{
		private GameObject generated;
		[CustomReadOnly, SerializeField]
		[ColourIfNull(1, 0, 0, 1)]
		private Spline _Spline = null;
		[HideInInspector] public bool toUpdate = true;

		[AsButton("Update","UpdateCommand", null)]
		[SerializeField] bool UpdateButton;
		[AsButton("Reset Data To Default","HandleDataComponentForSpawnedObjects", new object[]{true})]
		[SerializeField] bool DataResetButton;

		[Header("Main Placement")]
		//[Delayed]
		public Vector2 _spacingRange_ = new Vector2 (20,20);
		private Vector2 _rememberspacingRange_ = new Vector2 (20,20);
		[Tooltip("If not negative, will not place more than this number. Use zero to prevent anything placed normally."), Min(-1)]
		[Delayed]
		public int      _maxNumber_ = -1;

		[DrawHorizontalWithOthers(new string[]{"_spaceFromEnd_"})]
		[Tooltip("How far along the spline until objects start being placed."), Min(-1)]
		[Delayed]
		public float _spaceFromStart_ = 0f;
		[Tooltip("How far from the end of the spline when objects can no longer be placed.")]
		[Delayed]
		[HideInInspector]
		public float _spaceFromEnd_ = 0f;

		[Header("Additional Placement")]
		[DrawHorizontalWithOthers(new string[]{"_addOnEnd_"})]
		[Tooltip("If true, place an additional object at distance 0. Set maxNumber to 0 to make this the only placed object"),]
		public bool     _addOnStart_ = false;
		[Tooltip("If true, place an additional object at the furthest distance."),]
		[HideInInspector]
		public bool         _addOnEnd_;

		[Header("Object")]
		[ColourIfNull(1,0.2f,0.2f,1)]
		[Tooltip("Select the prefab to place along this spline. EG, rings.")]
		public GameObject _PrefabToPlace_ = null;
		public bool _placeAsPrefab_ = true;

		[CustomReadOnly]
		public string _CurrentPrefabToSpawn;
		[CustomReadOnly, Tooltip("Read only. If placing objects with S_Data classes, that component will be added to this object, to control all of the placed ones' values.")]
		public S_Data_Base _DataForPrefabs;

		[Header("Transform")]
		[NonSerialized] public Vector3 _mainScale = new Vector3(1,1,1);
		[NonSerialized] public Vector3 _mainOffset, _mainRotation;

		public ElementTransform[] _TransformsPerPoint_ = new ElementTransform[1] { new ElementTransform() {_scale = Vector3.one }
		};

		[Serializable]
		public struct ElementTransform {
			public Vector3 _scale;
			public Vector3 _offset3d, _rotation;
		}

		[Space]
		public bool _alignWithTerrain_ = false;

#if UNITY_EDITOR

		private void OnEnable () {
			if (Application.isPlaying) { return; }
			CheckNow();
		}

		public void CheckNow () {
			string generatedName = "generated by " + GetType().Name;
			var generatedTranform = transform.Find(generatedName);
			generated = generatedTranform != null ? generatedTranform.gameObject : UOUtility.Create(generatedName, gameObject);

			_Spline = GetComponentInParent<Spline>();
			if (!_Spline) { 
				_Spline = GetComponent<Spline>();
				if (!_Spline) { return; }
			}
			_Spline.NodeListChanged += ( s, e ) =>
			{
				toUpdate = true;
				foreach (CubicBezierCurve curve in _Spline.GetCurves())
				{
					curve.Changed.AddListener(() => toUpdate = true);
				}
			};
			foreach (CubicBezierCurve curve in _Spline.GetCurves())
			{
				curve.Changed.AddListener(() => toUpdate = true);
			}
		}

		private void OnValidate () {
			if (_TransformsPerPoint_ == null || _TransformsPerPoint_.Length == 0) 
			{
				_TransformsPerPoint_ = new ElementTransform[1] { new ElementTransform() { _scale = Vector3.one } };
			}

			_mainScale = _TransformsPerPoint_[0]._scale;
			_mainOffset = _TransformsPerPoint_[0]._offset3d;
			_mainRotation = _TransformsPerPoint_[0]._rotation;

			toUpdate = true; //OnValidate cant destroy anything, so tell Update to do so.

			if (!_Spline) { return; }

			//Ensure spacing can't go behind length of spline.
			_spaceFromEnd_ = MathF.Min(_spaceFromEnd_, _Spline.Length);
			_spaceFromStart_ = MathF.Min(_spaceFromStart_, _Spline.Length);

			if(_rememberspacingRange_.y != _spacingRange_.y)
				_spacingRange_.x = Mathf.Min(_spacingRange_.x, _spacingRange_.y);
			else
				_spacingRange_.y = Mathf.Max(_spacingRange_.x, _spacingRange_.y);

			_rememberspacingRange_ = _spacingRange_;
		}


		private void LateUpdate () {
			if (Application.isPlaying) { return; }

			if (toUpdate)
			{
				PlaceAllElements();
				toUpdate = false;

				HandleDataComponentForSpawnedObjects();
			}
		}

		public void PlaceAllElements () {
			if (!_Spline) { return; }

			UOUtility.DestroyChildren(generated);

			//Only place if there is space and a valid object.
			if (Math.Max(_spacingRange_.x, _spacingRange_.y) <= 0 || _PrefabToPlace_ == null) { return; }

			//These placements are easier, so happen seperate from the main calculation along spline.
			if (_addOnEnd_)
			{
				PlaceElementsAtPoint(_Spline.Length - 1);
			}
			if (_addOnStart_)
			{
				PlaceElementsAtPoint(1);
			}

			//Place along spline from start to end.
			float distance = _spaceFromStart_;

			//Loop until the new distance to place would exceed the boundry.
			for (int i = 1 ; distance <= (_Spline.Length - _spaceFromEnd_) ; i++)
			{
				//Ensure number of objects placed doesn't exceed the limit.
				if (_maxNumber_ >= 0 && i > _maxNumber_) { break; }

				PlaceElementsAtPoint(distance);
				distance += UnityEngine.Random.Range(_spacingRange_.x, _spacingRange_.y); //Find next position to place on.
			}
		}

		void PlaceElementsAtPoint ( float atDistance ) {
			for (int t = 0 ; t < _TransformsPerPoint_.Length ; t++)
			{
				PlaceSingleElement(atDistance, _TransformsPerPoint_[t]);
			}
		}

		void PlaceSingleElement ( float atDistance, ElementTransform TransformStruct) {
			CurveSample sample = _Spline.GetSampleAtDistance(atDistance);

			GameObject GO;
			if (!_placeAsPrefab_)
			{
				GO = Instantiate(_PrefabToPlace_, generated.transform);
			}
			else
			{
				GO = PrefabUtility.InstantiatePrefab(_PrefabToPlace_) as GameObject;
				GO.transform.parent = generated.transform;
			}
			GO.transform.localRotation = Quaternion.identity;
			GO.transform.localPosition = Vector3.zero;
			GO.transform.localScale = Vector3.one;

			Spline.SampleTransforms sampleTransforms = Spline.GetSampleTransformInfo(transform, sample);

			// Apply position from spline point and offset
			GO.transform.position = sampleTransforms.location;

			// move orthogonaly to the spline, according to offset + random
			Vector3 binormal = sampleTransforms.forwards;

			binormal += sampleTransforms.rotation * TransformStruct._offset3d;
			GO.transform.position += binormal;

			// apply scale
			GO.transform.localScale = new Vector3(TransformStruct._scale.x, TransformStruct._scale.y, TransformStruct._scale.z);
			// rotate with random yaw
			GO.transform.rotation = sampleTransforms.rotation * Quaternion.Euler(TransformStruct._rotation);


			if (_alignWithTerrain_) GroundAlign(GO.transform);

			ApplyDataToSpawnedObject(GO);
		}

		void GroundAlign ( Transform obj ) {
			RaycastHit hit;
			Ray ray = new Ray(obj.position, Vector3.down);
			ray = new Ray(obj.position, -obj.up);
			if (Physics.Raycast(ray, out hit))
			{
				obj.position = hit.point;
				obj.rotation = Quaternion.FromToRotation(obj.up, hit.normal) * obj.rotation;
				obj.position += _mainOffset;
			}

		}
		public void HandleDataComponentForSpawnedObjects (bool overide = false) {

			if (!_PrefabToPlace_)
			{
				_CurrentPrefabToSpawn = "";
				if (_DataForPrefabs != null) DestroyImmediate(_DataForPrefabs);
				_DataForPrefabs = null;
				return;
			}

			//If prefab to spawn was changed
			if (_PrefabToPlace_.name != _CurrentPrefabToSpawn || overide) //Overide is set as true when this method is called from the AsButton field.
			{
				_CurrentPrefabToSpawn = _PrefabToPlace_.name;
				if (_DataForPrefabs != null) DestroyImmediate(_DataForPrefabs);
				_DataForPrefabs = null;

				//If the prefab to spawn inherits from the data class, add that class as a component to this, to allow full control of the spawned objects' values.
				if (_PrefabToPlace_.TryGetComponent(out S_Data_Base DataBase))
				{
					Type derivedType = DataBase.GetType();
					// Add a component of the actual derived class
					S_S_Editor.AddComponentIfMissing(gameObject, derivedType);
					_DataForPrefabs = GetComponent<S_Data_Base>();

					EditorUtility.CopySerialized(DataBase, _DataForPrefabs);

					_DataForPrefabs.enabled = false;
				}
			}

		}
		private void ApplyDataToSpawnedObject ( GameObject go ) {

			_DataForPrefabs = GetComponent<S_Data_Base>();
			if (!_DataForPrefabs) { return; }
			if (_PrefabToPlace_.name != _CurrentPrefabToSpawn) { return; }

			//If the prefab to spawn inherits from the data class, add that class as a component to this, to allow full control of the spawned objects' values.
			if (go.TryGetComponent(out S_Data_Base DataBase))
			{
				if(_DataForPrefabs.GetType() != DataBase.GetType()) { return; }
				EditorUtility.CopySerialized(_DataForPrefabs, DataBase);

				_DataForPrefabs.enabled = false;
				DataBase.enabled = true;
			}
		}

		public void UpdateCommand () {
			CheckNow();
			PlaceAllElements();
		}
#endif
	}

}


