using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using System.ComponentModel;

#if UNITY_EDITOR
using UnityEditor;
#endif

namespace SplineMesh
{
	/// <summary>
	/// Example of component to places assets along a spline. This component can be used as-is but will most likely be a base for your own component.
	/// 
	/// In this example, the user gives the prefab to place, a spacing value between two placements, the prefab scale and an horizontal offset to the spline.
	/// These three last values have an additional range, allowing to add some randomness. for each placement, the computed value will be between value and value+range.
	/// 
	/// Prefabs are placed from the start of the spline at computed spacing, unitl there is no lentgh remaining. Prefabs are stored, destroyed
	/// and built again each time the spline or one of its curves change.
	/// 
	/// A random seed is used to obtain the same random numbers at each update. The user can specify the seed to test some other random number set.
	/// 
	/// Place prefab along a spline and deform it easily have a lot of usages if you have some imagination : 
	///  - place trees along a road
	///  - create a rocky bridge
	///  - create a footstep track with decals
	///  - create a path of firefly in the dark
	///  - create a natural wall with overlapping rocks
	///  - etc.
	/// </summary>
	[ExecuteInEditMode]
	[SelectionBase]
	[DisallowMultipleComponent]
	public class S_PlaceOnSpline : MonoBehaviour
	{
		private GameObject generated;
		private Spline _Spline = null;
		[HideInInspector] public bool toUpdate = true;

		[Header("Placement")]
		public bool justStart = true;
		public bool onlyOne = false;
		public bool none = false;
		public bool onEnd;

		[Header("Object")]
		public GameObject prefab = null;
		public bool asPrefab = true;

		private GameObject CurrentPrefabToSpawn;
		[ReadOnly(true)]
		public S_Data_Base DataForPrefabs;

		[Header("Transform")]
		public float scale = 1, scaleRange = 0;
		public float spacing = 20, spacingRange = 0;
		public float offset = 0, offsetRange = 0;
		public Vector3 Offset3d, offsetRotation;

		[Header("on Spline")]
		public float initialSpacing = 0f;
		public float EndingSpacing = 0f;
		public bool isRandomYaw = false;
		public int randomSeed = 0;
		[Space]
		public bool alingwithterrain = false;

#if UNITY_EDITOR
		private void OnEnable () {
			if (Application.isPlaying) { return; }
			CheckNow();
		}

		public void CheckNow () {
			string generatedName = "generated by " + GetType().Name;
			var generatedTranform = transform.Find(generatedName);
			generated = generatedTranform != null ? generatedTranform.gameObject : UOUtility.Create(generatedName, gameObject);

			_Spline = GetComponentInParent<Spline>();
			_Spline.NodeListChanged += ( s, e ) =>
			{
				toUpdate = true;
				foreach (CubicBezierCurve curve in _Spline.GetCurves())
				{
					curve.Changed.AddListener(() => toUpdate = true);
				}
			};
			foreach (CubicBezierCurve curve in _Spline.GetCurves())
			{
				curve.Changed.AddListener(() => toUpdate = true);
			}
		}

		private void OnValidate () {
			toUpdate = true;

			HandleDataComponentForSpawnedObjects();
		}


		private void Update () {
			if (Application.isPlaying) { return; }

			if (toUpdate)
			{
				Sow();
				toUpdate = false;
			}
		}

		public void Sow () {
			UOUtility.DestroyChildren(generated);


			UnityEngine.Random.InitState(randomSeed);
			if (spacing + spacingRange <= 0 ||
			    prefab == null)
				return;

			float distance = initialSpacing;

			if (onEnd)
			{
				PlaceElement(_Spline.Length);
			}

			if (none)
				return;

			else if (justStart)
			{
				PlaceElement(1);
			}
			else if (onlyOne)
			{
				PlaceElement(initialSpacing);
			}
			else
			{
				while (distance <= (_Spline.Length - EndingSpacing))
				{
					PlaceElement(distance);
					distance += spacing + UnityEngine.Random.Range(0, spacingRange);
				}
			}

		}

		void PlaceElement ( float distance ) {
			CurveSample sample = _Spline.GetSampleAtDistance(distance);

			GameObject go;
			if (!asPrefab)
			{
				go = Instantiate(prefab, generated.transform);
			}
			else
			{
#if UNITY_EDITOR
				go = PrefabUtility.InstantiatePrefab(prefab) as GameObject;
#else
                    go = Instantiate(prefab, generated.transform);
#endif
				go.transform.parent = generated.transform;
			}
			go.transform.localRotation = Quaternion.identity;
			go.transform.localPosition = Vector3.zero;
			go.transform.localScale = Vector3.one;

			// move along spline, according to spacing + random
			go.transform.position = transform.position + (transform.rotation * sample.location);
			// apply scale + random
			float rangedScale = scale + UnityEngine.Random.Range(0, scaleRange);
			go.transform.localScale = new Vector3(rangedScale, rangedScale, rangedScale);
			// rotate with random yaw
			if (isRandomYaw)
			{
				go.transform.Rotate(0, 0, UnityEngine.Random.Range(-180, 180));
			}
			else
			{
				go.transform.rotation = transform.rotation * sample.Rotation * Quaternion.Euler(offsetRotation);
			}
			// move orthogonaly to the spline, according to offset + random
			Vector3 binormal = sample.tangent;
			binormal = Quaternion.LookRotation(Vector3.right, Vector3.up) * binormal;
			var localOffset = offset + UnityEngine.Random.Range(0, offsetRange * Math.Sign(offset));
			localOffset *= sample.scale.x;
			binormal *= localOffset;
			binormal += transform.rotation * sample.Rotation * Offset3d;
			go.transform.position += binormal;

			if (alingwithterrain) GroundAlign(go.transform);

			ApplyDataToSpawnedObject(go);
		}

		void GroundAlign ( Transform obj ) {
			RaycastHit hit;
			Ray ray = new Ray(obj.position, Vector3.down);
			ray = new Ray(obj.position, -obj.up);
			if (Physics.Raycast(ray, out hit))
			{
				obj.position = hit.point;
				obj.rotation = Quaternion.FromToRotation(obj.up, hit.normal) * obj.rotation;
				obj.position += Offset3d;
			}

		}
		private void HandleDataComponentForSpawnedObjects () {

			//If prefab to spawn was changed
			if (prefab != CurrentPrefabToSpawn)
			{
				CurrentPrefabToSpawn = prefab;
				if (DataForPrefabs != null) DestroyImmediate(DataForPrefabs, true);
				DataForPrefabs = null;

				//If the prefab to spawn inherits from the data class, add that class as a component to this, to allow full control of the spawned objects' values.
				if (prefab.TryGetComponent(out S_Data_Base DataBase))
				{
					Type derivedType = DataBase.GetType();
					// Add a component of the actual derived class
					S_S_EditorMethods.AddComponentIfMissing(gameObject, derivedType);
					DataForPrefabs = GetComponent<S_Data_Base>();

					EditorUtility.CopySerialized(DataBase, DataForPrefabs);

					DataForPrefabs.enabled = false;
				}
			}

		}

		private void ApplyDataToSpawnedObject (GameObject go) {
			if(!DataForPrefabs) { return; }
			//If the prefab to spawn inherits from the data class, add that class as a component to this, to allow full control of the spawned objects' values.
			if (go.TryGetComponent(out S_Data_Base DataBase))
			{
				EditorUtility.CopySerialized(DataForPrefabs, DataBase);

				DataForPrefabs.enabled = false;
				DataBase.enabled = true;
			}
		}

		public S_O_CustomInspectorStyle _InspectorTheme;
#endif
	}



#if UNITY_EDITOR
	[CustomEditor(typeof(S_PlaceOnSpline))]
	public class PlaceOnSplineEditor : S_CustomInspector_Base
	{
		S_PlaceOnSpline _OwnerScript;

		public override void OnEnable () {
			//Setting variables
			_OwnerScript = (S_PlaceOnSpline)target;
			_InspectorTheme = _OwnerScript._InspectorTheme;

			base.OnEnable();
		}

		public override S_O_CustomInspectorStyle GetInspectorStyleFromSerializedObject () {
			return _OwnerScript._InspectorTheme;
		}

		public override void DrawInspectorNotInherited () {

			//Order of Drawing
			EditorGUILayout.Space(_spaceSize);
			DrawButtons();

			void DrawButtons () {
				EditorGUILayout.Space(_spaceSize);

				if (S_S_CustomInspectorMethods.IsDrawnButtonPressed(serializedObject, "Update", _BigButtonStyle, _OwnerScript, "Update Single Spline Meshes"))
				{
					_OwnerScript.CheckNow();
					_OwnerScript.Sow();
				}
				serializedObject.ApplyModifiedProperties();
			}

			DrawDefaultInspector();
		}
	}
#endif
}


