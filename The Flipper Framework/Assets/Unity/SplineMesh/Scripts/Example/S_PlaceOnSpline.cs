using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using System.ComponentModel;

#if UNITY_EDITOR
using UnityEditor;
#endif

namespace SplineMesh
{
	/// <summary>
	/// Example of component to places assets along a spline. This component can be used as-is but will most likely be a base for your own component.
	/// 
	/// In this example, the user gives the prefab to place, a spacing value between two placements, the prefab scale and an horizontal offset to the spline.
	/// These three last values have an additional range, allowing to add some randomness. for each placement, the computed value will be between value and value+range.
	/// 
	/// Prefabs are placed from the start of the spline at computed spacing, unitl there is no lentgh remaining. Prefabs are stored, destroyed
	/// and built again each time the spline or one of its curves change.
	/// 
	/// A random seed is used to obtain the same random numbers at each update. The user can specify the seed to test some other random number set.
	/// 
	/// Place prefab along a spline and deform it easily have a lot of usages if you have some imagination : 
	///  - place trees along a road
	///  - create a rocky bridge
	///  - create a footstep track with decals
	///  - create a path of firefly in the dark
	///  - create a natural wall with overlapping rocks
	///  - etc.
	/// </summary>
	[ExecuteInEditMode]
	[SelectionBase]
	[DisallowMultipleComponent]
	public class S_PlaceOnSpline : MonoBehaviour
	{
		private GameObject generated;
		private Spline _Spline = null;
		[HideInInspector] public bool toUpdate = true;

		[Header("Main Placement")]
		public Vector2 _spacingRange_ = new Vector2 (20,20);
		[Tooltip("If not negative, will not place more than this number. Use zero to prevent anything placed normally."), Min(-1)]
		public int	_maxNumber_ = -1;
		[Tooltip("How far along the spline until objects start being placed."), Min(-1)]
		public float _spaceFromStart_ = 0f;
		[Tooltip("How far from the end of the spline when objects can no longer be placed.")]
		public float _spaceFromEnd_ = 0f;

		[Header("Additional Placement")]
		[Tooltip("If true, place an additional object at distance 0. Set maxNumber to 0 to make this the only placed object"),]
		public bool	_addOnStart_ = false;
		[Tooltip("If true, place an additional object at the furthest distance."),]
		public bool         _addOnEnd_;

		[Header("Object")]
		[ColourIfNull(1,0.2f,0.2f,1)]
		[Tooltip("Select the prefab to place along this spline. EG, rings.")]
		public GameObject _PrefabToPlace_ = null;
		public bool _placeAsPrefab_ = true;

		private GameObject _CurrentPrefabToSpawn;
		[CustomReadOnly, Tooltip("Read only. If placing objects with S_Data classes, that component will be added to this object, to control all of the placed ones' values.")]
		public S_Data_Base _DataForPrefabs;

		[Header("Transform")]
		public Vector3 _scale_ = new Vector3(1,1,1);
		public Vector3 _offset3d_, _offsetRotation_;

		[Space]
		public bool _alignWithTerrain_ = false;

#if UNITY_EDITOR
		private void OnEnable () {
			if (Application.isPlaying) { return; }
			CheckNow();
		}

		public void CheckNow () {
			string generatedName = "generated by " + GetType().Name;
			var generatedTranform = transform.Find(generatedName);
			generated = generatedTranform != null ? generatedTranform.gameObject : UOUtility.Create(generatedName, gameObject);

			_Spline = GetComponentInParent<Spline>();
			_Spline.NodeListChanged += ( s, e ) =>
			{
				toUpdate = true;
				foreach (CubicBezierCurve curve in _Spline.GetCurves())
				{
					curve.Changed.AddListener(() => toUpdate = true);
				}
			};
			foreach (CubicBezierCurve curve in _Spline.GetCurves())
			{
				curve.Changed.AddListener(() => toUpdate = true);
			}
		}

		private void OnValidate () {
			toUpdate = true; //OnValidate cant destroy anything, so tell Update to do so.

			if (!_Spline) { return; }

			//Ensure spacing can't go behind length of spline.
			_spaceFromEnd_ = MathF.Min(_spaceFromEnd_, _Spline.Length);
			_spaceFromStart_ = MathF.Min(_spaceFromStart_, _Spline.Length);
		}


		private void LateUpdate () {
			if (Application.isPlaying) { return; }

			if (toUpdate)
			{
				PlaceAllElements();
				toUpdate = false;

				HandleDataComponentForSpawnedObjects();
			}
		}

		public void PlaceAllElements () {
			UOUtility.DestroyChildren(generated);

			//Only place if there is space and a valid object.
			if (Math.Max(_spacingRange_.x, _spacingRange_.y) <= 0 || _PrefabToPlace_ == null) { return; }

			//These placements are easier, so happen seperate from the main calculation along spline.
			if (_addOnEnd_)
			{
				PlaceSingleElement(_Spline.Length - 1);
			}
			if (_addOnStart_)
			{
				PlaceSingleElement(1);
			}

			//Place along spline from start to end.
			float distance = _spaceFromStart_;

			//Loop until the new distance to place would exceed the boundry.
			for (int i = 1 ; distance <= (_Spline.Length - _spaceFromEnd_) ; i++)
			{
				//Ensure number of objects placed doesn't exceed the limit.
				if (_maxNumber_ >= 0 && i > _maxNumber_) { break; }

				PlaceSingleElement(distance);
				distance += UnityEngine.Random.Range(_spacingRange_.x, _spacingRange_.y); //Find next position to place on.
			}
		}

		void PlaceSingleElement ( float atDistance ) {
			CurveSample sample = _Spline.GetSampleAtDistance(atDistance);

			GameObject GO;
			if (!_placeAsPrefab_)
			{
				GO = Instantiate(_PrefabToPlace_, generated.transform);
			}
			else
			{
				GO = PrefabUtility.InstantiatePrefab(_PrefabToPlace_) as GameObject;
				GO.transform.parent = generated.transform;
			}
			GO.transform.localRotation = Quaternion.identity;
			GO.transform.localPosition = Vector3.zero;
			GO.transform.localScale = Vector3.one;

			// Apply position from spline point and offset
			GO.transform.position = transform.position + (transform.rotation * sample.location);

			// move orthogonaly to the spline, according to offset + random
			Vector3 binormal = sample.tangent;

			binormal += transform.rotation * sample.Rotation * _offset3d_;
			GO.transform.position += binormal;

			// apply scale
			GO.transform.localScale = new Vector3(_scale_.x, _scale_.y, _scale_.z);
			// rotate with random yaw
			GO.transform.rotation = transform.rotation * sample.Rotation * Quaternion.Euler(_offsetRotation_);
			

			if (_alignWithTerrain_) GroundAlign(GO.transform);

			ApplyDataToSpawnedObject(GO);
		}

		void GroundAlign ( Transform obj ) {
			RaycastHit hit;
			Ray ray = new Ray(obj.position, Vector3.down);
			ray = new Ray(obj.position, -obj.up);
			if (Physics.Raycast(ray, out hit))
			{
				obj.position = hit.point;
				obj.rotation = Quaternion.FromToRotation(obj.up, hit.normal) * obj.rotation;
				obj.position += _offset3d_;
			}

		}
		public void HandleDataComponentForSpawnedObjects (bool overwrite = false) {

			//If prefab to spawn was changed
			if (_PrefabToPlace_ != _CurrentPrefabToSpawn || overwrite)
			{
				_CurrentPrefabToSpawn = _PrefabToPlace_;
				if (_DataForPrefabs != null) DestroyImmediate(_DataForPrefabs);
				_DataForPrefabs = null;

				//If the prefab to spawn inherits from the data class, add that class as a component to this, to allow full control of the spawned objects' values.
				if (_PrefabToPlace_.TryGetComponent(out S_Data_Base DataBase))
				{
					Type derivedType = DataBase.GetType();
					// Add a component of the actual derived class
					S_S_EditorMethods.AddComponentIfMissing(gameObject, derivedType);
					_DataForPrefabs = GetComponent<S_Data_Base>();

					EditorUtility.CopySerialized(DataBase, _DataForPrefabs);

					_DataForPrefabs.enabled = false;
				}
			}

		}

		private void ApplyDataToSpawnedObject (GameObject go) {
			if(!_DataForPrefabs) { return; }
			//If the prefab to spawn inherits from the data class, add that class as a component to this, to allow full control of the spawned objects' values.
			if (go.TryGetComponent(out S_Data_Base DataBase))
			{
				EditorUtility.CopySerialized(_DataForPrefabs, DataBase);

				_DataForPrefabs.enabled = false;
				DataBase.enabled = true;
			}
		}

		public S_O_CustomInspectorStyle _InspectorTheme;
#endif
	}



#if UNITY_EDITOR
	[CustomEditor(typeof(S_PlaceOnSpline))]
	public class PlaceOnSplineEditor : S_CustomInspector_Base
	{
		S_PlaceOnSpline _OwnerScript;

		public override void OnEnable () {
			//Setting variables
			_OwnerScript = (S_PlaceOnSpline)target;
			_InspectorTheme = _OwnerScript._InspectorTheme;

			base.OnEnable();
		}

		public override S_O_CustomInspectorStyle GetInspectorStyleFromSerializedObject () {
			return _OwnerScript._InspectorTheme;
		}

		public override void DrawInspectorNotInherited () {

			//Order of Drawing
			EditorGUILayout.Space(_spaceSize);
			DrawButtons();

			void DrawButtons () {
				EditorGUILayout.Space(_spaceSize);

				if (S_S_CustomInspectorMethods.IsDrawnButtonPressed(serializedObject, "Update", _BigButtonStyle, _OwnerScript, "Update Placed Object"))
				{
					_OwnerScript.CheckNow();
					_OwnerScript.PlaceAllElements();
				}
				if (S_S_CustomInspectorMethods.IsDrawnButtonPressed(serializedObject, "Reset Data To Default", _BigButtonStyle, _OwnerScript, "Default Data on Placed Object"))
				{
					_OwnerScript.HandleDataComponentForSpawnedObjects(true);
				}
				serializedObject.ApplyModifiedProperties();
			}

			DrawDefaultInspector();
		}
	}
#endif
}


