using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEditor;
using System.Collections;
using SplineMesh;
using templates;
using Unity.VisualScripting;

namespace SplineMesh
{

	/// <summary>
	/// Deform a mesh and place it along a spline, given various parameters.
	/// 
	/// This class intend to cover the most common situations of mesh bending. It can be used as-is in your project,
	/// or can serve as a source of inspiration to write your own procedural generator.
	/// </summary>
	[ExecuteInEditMode]
	[SelectionBase]
	[DisallowMultipleComponent]
	public class S_SplineMeshTiling : MonoBehaviour
	{
		private GameObject generated;
		[CustomReadOnly]
		[SerializeField] Spline _Spline = null;
		private bool toUpdate = false;

		[AsButton("Update Self","UpdateSelfCommand", null)]
		[SerializeField] bool UpdateButton;
		[AsButton("Update All","UpdateAllCommand", null)]
		[SerializeField] bool UpdateAllButton;

		[Header("Object")]
		[Tooltip("Mesh to bend along the spline.")]
		public Mesh mesh;
		[Tooltip("Material to apply on the bent mesh.")]
		public Material material;
		[Tooltip("Physic material to apply on the bent mesh.")]
		public PhysicMaterial physicMaterial;
		[Tooltip("Translation to apply on the mesh before bending it.")]
		public Vector3 translation;
		[Tooltip("Rotation to apply on the mesh before bending it.")]
		public Vector3 rotation;
		[Tooltip("Scale to apply on the mesh before bending it.")]
		public Vector3 scale = Vector3.one;

		[Header("Components")]
		[DrawHorizontalWithOthers(new string[]{"updateInPlayMode"})]
		public bool DeactivateOnStart;

		[Tooltip("If true, the mesh will be bent on play mode. If false, the bent mesh will be kept from the editor mode, allowing lighting baking.")]
		[HideInInspector]
		public bool updateInPlayMode;

		[Tooltip("If true, a mesh will be placed on each curve of the spline. If false, a single mesh will be placed for the whole spline.")]
		public bool curveSpace = false;

		[DrawHorizontalWithOthers(new string[]{"enableCollider"})]
		public bool enableCollider = false;
		[HideInInspector]
		public bool enableVisual = true;
		[DrawHorizontalWithOthers(new string[]{"ObjLayer"}, new float[] {1f, 1f })]
		public string ObjTag = "Rail";
		[HideInInspector]
		public int ObjLayer = 23;

		public GameObject refDir;
		[DrawHorizontalWithOthers(new string[]{"showStartDir"}, new float[] {1.3f, 0.7f })]
		public bool showEndDir;
		[HideInInspector]
		public bool showStartDir;


		[Tooltip("The mode to use to fill the choosen interval with the bent mesh.")]
		public S_MeshBender.FillingMode mode = S_MeshBender.FillingMode.Repeat;

#if UNITY_EDITOR
		private void OnEnable () {
			// tip : if you name all generated content in the same way, you can easily find all of it
			// at once in the scene view, with a single search.
			GenerateChild();
			SetSpline();

			toUpdate = true;
		}

		private void SetSpline () {
			if(!TryGetComponent(out _Spline))
			{
				_Spline = GetComponentInParent<Spline>();
			}
			else if(!_Spline) { enabled = false; }
		}

		private void GenerateChild () {
			string generatedName = "generated by " + GetType().Name;
			var generatedTranform = transform.Find(generatedName);
			generated = generatedTranform != null ? generatedTranform.gameObject : UOUtility.Create(generatedName, gameObject);

		}

		private void OnValidate () {
			if (_Spline == null) return;
			toUpdate = true;

			if(!generated) { GenerateChild(); }
		}

		private void Update () {
			// we can prevent the generated content to be updated during playmode to preserve baked data saved in the scene
			if (!updateInPlayMode && Application.isPlaying) return;

			if (toUpdate)
			{
				toUpdate = false;
				CreateMeshes();
			}
		}

		public void Rebuild () {
			//curveSpace = !curveSpace;
			//CreateMeshes();
			//curveSpace = !curveSpace;
			if (curveSpace)
			{
				int i = 0;
				if(_Spline == null) { return; }
				foreach (var curve in _Spline.curves)
				{
					var go = FindOrCreate("segment " + i++ + " mesh");
					DestroyImmediate(go);
				}
			}
			else
			{
				var go = FindOrCreate("segment 1 mesh");
				DestroyImmediate(go);
			}

			CreateMeshes();
		}

		public void CreateMeshes () {
			var used = new List<GameObject>();

			if (curveSpace)
			{
				int i = 0;
				foreach (var curve in _Spline.curves)
				{
					var go = FindOrCreate("segment " + i++ + " mesh");
					go.GetComponent<S_MeshBender>().SetInterval(curve);
					used.Add(go);
				}
			}
			else
			{
				var go = FindOrCreate("segment 1 mesh");
				go.GetComponent<S_MeshBender>().SetInterval(_Spline, 0);
				used.Add(go);
			}

			// we destroy the unused objects. This is classic pooling to recycle game objects.
			foreach (var go in generated.transform
			    .Cast<Transform>()
			    .Select(child => child.gameObject).Except(used))
			{
				UOUtility.Destroy(go);
			}

			if (showEndDir && refDir != null)
			{
				GameObject go = Instantiate(refDir, generated.transform);

				CurveSample sample = _Spline.GetSampleAtDistance(_Spline.Length);


				go.transform.localPosition = sample.location;
				go.transform.rotation = Quaternion.LookRotation(sample.up, sample.tangent);

			}

			if (showStartDir && refDir != null)
			{
				GameObject go = Instantiate(refDir, generated.transform);

				CurveSample sample = _Spline.GetSampleAtDistance(0);

				go.transform.localPosition = sample.location;
				go.transform.rotation = Quaternion.LookRotation(sample.up, sample.tangent);

			}
		}

		private GameObject FindOrCreate ( string name ) {
			if (!generated || generated.IsDestroyed()) { GenerateChild(); }
			var childTransform = generated.transform.Find(name);
			GameObject newObject = S_S_Editor.FindOrCreateChild(generated, name, 
				new Type[] { typeof(MeshFilter),
				    typeof(MeshRenderer),
				    typeof(S_MeshBender),
				    typeof(S_DeactivateOnStart),
				    typeof(MeshCollider)}	);

			////Creates a GameObject with the following components
			//if (childTransform == null)
			//{
			//	res = UOUtility.Create(name,
			//	    generated,
			//	    typeof(MeshFilter),
			//	    typeof(MeshRenderer),
			//	    typeof(S_MeshBender),
			//	    typeof(S_DeactivateOnStart),
			//	    typeof(MeshCollider));
			//	res.isStatic = true;
			//}
			//else
			//{
			//	res = childTransform.gameObject;
			//}

			//Sets variables of the components
			newObject.GetComponent<MeshRenderer>().material = material;
			newObject.GetComponent<MeshCollider>().material = physicMaterial;
			newObject.GetComponent<MeshCollider>().enabled = enableCollider;
			newObject.GetComponent<MeshRenderer>().enabled = enableVisual;
			newObject.GetComponent<S_DeactivateOnStart>().enabled = DeactivateOnStart;

			//Overwrite set tag and layer
			newObject.tag = ObjTag;
			newObject.layer = ObjLayer;

			S_MeshBender mb =  newObject.GetComponent<S_MeshBender>();
			if (mb == null){mb = newObject.AddComponent<S_MeshBender>();}

			mb.Source = SourceMesh.Build(mesh)
			   .Translate(translation)
			   .Rotate(Quaternion.Euler(rotation))
			   .Scale(scale);
			mb.Mode = mode;

			return newObject;
		}

		public void UpdateAllCommand () {
			S_SplineMeshTiling[] railsMeshes = FindObjectsByType<S_SplineMeshTiling>((FindObjectsSortMode.None));
			foreach (S_SplineMeshTiling mesh in railsMeshes)
			{
				mesh.Rebuild();
			}
		}

		public void UpdateSelfCommand () {
			Rebuild();
		}
#endif
	}
}